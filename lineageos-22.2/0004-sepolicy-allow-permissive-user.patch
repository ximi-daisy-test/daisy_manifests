bypass sepolicy check

--- a/system/sepolicy/build/soong/policy.go
+++ b/system/sepolicy/build/soong/policy.go
@@ -530,38 +530,6 @@
 	}
 	rule.Temporary(bin)
 
-	// permissive check is performed only in user build (not debuggable).
-	if !ctx.Config().Debuggable() {
-		permissiveDomains := pathForModuleOut(ctx, c.stem()+"_permissive")
-		cmd := rule.Command().BuiltTool("sepolicy-analyze").
-			Input(bin).
-			Text("permissive")
-		// Filter-out domains listed in permissive_domains_on_user_builds
-		allowedDomains := c.properties.Permissive_domains_on_user_builds
-		if len(allowedDomains) != 0 {
-			cmd.Text("| { grep -Fxv")
-			for _, d := range allowedDomains {
-				cmd.FlagWithArg("-e ", proptools.ShellEscape(d))
-			}
-			cmd.Text(" || true; }") // no match doesn't fail the cmd
-		}
-		cmd.Text(" > ").Output(permissiveDomains)
-		rule.Temporary(permissiveDomains)
-
-		msg := `==========\n` +
-			`ERROR: permissive domains not allowed in user builds\n` +
-			`List of invalid domains:`
-
-		rule.Command().Text("if test").
-			FlagWithInput("-s ", permissiveDomains).
-			Text("; then echo").
-			Flag("-e").
-			Text(`"` + msg + `"`).
-			Text("&& cat ").
-			Input(permissiveDomains).
-			Text("; exit 1; fi")
-	}
-
 	out := pathForModuleOut(ctx, c.stem())
 	rule.Command().Text("cp").
 		Flag("-f").

